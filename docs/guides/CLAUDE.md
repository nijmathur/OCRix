# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Build & Run Commands

### Development
- **Install dependencies**: `flutter pub get`
- **Generate code** (run after modifying JSON serialization): `dart run build_runner build`
- **Run app**: `flutter run`
- **Run app on specific device**: `flutter run -d <device-id>`
- **Clean build**: `flutter clean && flutter pub get`

### Testing
- **Run all tests**: `flutter test`
- **Run specific test file**: `flutter test test/widget_test.dart`
- **Run integration tests**: `flutter test test/integration/`
- **Run with coverage**: `flutter test --coverage`

### Build for Production
- **Android APK**: `flutter build apk --release`
- **Android App Bundle**: `flutter build appbundle --release`
- **iOS**: `flutter build ios --release`
- **Web**: `flutter build web --release`
- **Desktop**: `flutter build windows|macos|linux --release`

### Code Analysis
- **Analyze code**: `flutter analyze`
- **Format code**: `dart format .`

## High-Level Architecture

### Layered Architecture Pattern

OCRix follows a clean architecture with clear separation of concerns:

```
Presentation (UI) → State Management (Providers) → Business Logic (Services) → Data (Database/Storage)
```

**Key architectural principles (SOLID):**
1. **Single Responsibility**: Each service has one clear purpose (e.g., LogFormatterService only formats logs)
2. **Open/Closed**: Services implement interfaces, allowing extension without modification
3. **Liskov Substitution**: Services can be substituted with their interface types for testing
4. **Interface Segregation**: Separate interfaces for each concern (`IDatabaseService`, `IOCRService`, etc.)
5. **Dependency Inversion**: Services depend on abstractions (interfaces), not concrete implementations
6. **DRY Pattern**: Common functionality centralized in `BaseService` and `AppConfig`
7. **Provider-based DI**: Riverpod providers inject service implementations into UI layer
8. **Singleton Services**: Core services use singleton pattern (transitioning to pure DI)

### Core Services Layer

All services extend `BaseService` and implement their corresponding interface:

- **DatabaseService** (`IDatabaseService`): SQLite with FTS5 search, encryption, and audit triggers
- **EncryptionService** (`IEncryptionService`): AES-256 encryption and secure key storage
- **OCRService** (`IOCRService`): Google ML Kit text recognition
- **CameraService** (`ICameraService`): Camera operations and image capture
- **StorageProviderService** (`IStorageProviderService`): Cloud storage abstraction (Google Drive, etc.)
- **AuditLoggingService**: Comprehensive audit trail with COMPULSORY database logging
- **TroubleshootingLoggerService**: File-based logging for debugging

**Service Initialization Pattern:**
Services must be initialized via `initialize()` before use. The `AppInitializer` widget handles service initialization sequence in `lib/main.dart`.

### State Management with Riverpod

The app uses Riverpod for dependency injection and state management:

- **Providers** (`lib/providers/`): Provide service instances and manage UI state
- **Notifiers**: `StateNotifier` classes that manage complex state (e.g., `DocumentNotifier`)
- **FutureProvider**: For async data fetching (e.g., `documentListProvider`)
- **Provider.family**: For parameterized providers (e.g., `documentProvider` by ID)

**Important**: All providers are defined in provider files (e.g., `document_provider.dart`, `auth_provider.dart`) and consumed via `ref.read()` or `ref.watch()` in widgets.

### Data Models and Serialization

Models in `lib/models/` use `json_serializable` for JSON serialization:
- Models have `.g.dart` companion files generated by `build_runner`
- After modifying model classes with `@JsonSerializable()`, run: `dart run build_runner build`
- Models implement equality via `Equatable` package

### Database Architecture

**SQLite with encryption:**
- Database file encrypted at rest using `encrypt` package
- FTS5 virtual tables for full-text search
- SQLite triggers for automatic audit logging
- User ID context set via `setCurrentUserIdForTriggers()` for trigger identification

**Important patterns:**
- Database operations must set user ID context for audit triggers
- Use `ConflictAlgorithm.replace` for upsert operations
- Image data stored as encrypted BLOB in database

### Audit and Logging System

**Three-tier logging architecture:**

#### 1. Console Logging (Development)
- Via `Logger` package for development debugging
- Automatic logging in all services via `BaseService` methods: `logInfo()`, `logWarning()`, `logError()`, `logDebug()`

#### 2. Troubleshooting Logging (File-based)
**Location:** `{app_documents}/logs/app.log`

**SOLID Architecture:**
- `LogFormatterService`: Formats log entries with timestamps and emojis
- `LogFileService`: Manages file operations
- `LogRotationService`: Handles log rotation (24h interval, 10MB max, keeps 5 archives)
- `TroubleshootingLoggerService`: Coordinates logging operations

**Features:**
- In-memory buffer (last 100 entries)
- Log levels: debug, info, warning, error, critical
- User-exportable logs via `LogExportDialog` widget
- Log rotation to prevent disk space issues
- Archive location: `{app_documents}/logs/archive/app_{timestamp}.log`

**Usage in services:**
All services call `setTroubleshootingLogger()` during initialization to inject logger dependency.

#### 3. Audit Logging (Tamper-proof)
**Separate database:** `audit_log.db` (separate from main `privacy_documents.db`)

**Three logging levels (priority-based):**
1. **COMPULSORY (Priority 3)**: Always logged, cannot be disabled - all database reads/writes
2. **INFO (Priority 1)**: User actions - document operations, search, export/import
3. **VERBOSE (Priority 2)**: Navigation events - screen transitions

**Tamper-proof mechanisms:**
- SHA-256 checksum for each entry
- Chain verification (each entry links to previous via `previousEntryId` and `previousChecksum`)
- Read-only operations (INSERT only, no UPDATE/DELETE)
- Integrity verification via `verifyIntegrity()` method

**Automatic logging:**
- Database operations automatically logged via SQLite triggers
- Navigation logged via `AuditNavigationObserver` in main.dart
- User ID tracked for all operations (set via `setUserId()`)

**Configuration:**
```dart
// Set log level (default: COMPULSORY only)
auditService.setLogLevel(AuditLogLevel.info); // or .verbose
```

### Authentication and Security

**Multi-layered security:**
- **Google Sign-In**: Primary authentication (OAuth2)
- **Biometric Auth**: Optional fingerprint/face unlock for app access
- **Data Encryption**: AES-256 for all data at rest
- **Secure Storage**: Encryption keys in platform secure storage (Keychain/Keystore)
- **Password-Based Encryption**: PBKDF2 with 100,000 iterations for portable database exports

**Encryption Architecture:**
1. **Local Data Encryption**: AES-256 with device-specific keys in secure storage
2. **Database Export Encryption**: PBKDF2 + AES-256 with user-provided password
   - 100,000 iterations for key derivation (NIST recommended)
   - 32-byte unique salt per export
   - 16-byte unique IV per file
   - File format: `[Salt (32 bytes)][IV (16 bytes)][Encrypted Data]`
3. **IV Management**: Initialization Vector prepended to all encrypted data for portability
   - Each encryption operation generates a unique IV
   - IV stored with encrypted data (not secret, just needs to be unique)
   - Prevents need for persistent IV storage across app versions

**Biometric Auth Flow:**
- Enabled via `BiometricAuthNotifier` in `biometric_auth_provider.dart`
- App lifecycle listener in `AppInitializer` triggers biometric prompt on resume
- Fallback to Google Sign-In if biometric fails

### UI Screens

Screens in `lib/ui/screens/`:
- `SplashScreen`: App initialization loading
- `LoginScreen`: Google Sign-In authentication
- `HomeScreen`: Main document list and navigation
- `ScannerScreen`: Camera-based document scanning
- `DocumentDetailScreen`: View/edit document details
- `DocumentListScreen`: Searchable document grid/list
- `SettingsScreen`: App settings and preferences

**Key Widgets** in `lib/ui/widgets/`:
- `DocumentGrid`: Grid view for document display (configurable scroll behavior)
- `PasswordDialog`: Password input with strength indicator (for database export/import)
- `LogExportDialog`: Export troubleshooting logs
- `BiometricPrompt`: Biometric authentication UI

### Error Handling

**Global error handling:**
- App runs in `runZonedGuarded` to catch async errors
- `ErrorHandler` utility initialized with troubleshooting logger
- Custom exceptions in `lib/core/exceptions/app_exceptions.dart`

**Error types:**
1. Network errors (connectivity, API failures)
2. Storage errors (file system, database issues)
3. Security errors (authentication, encryption failures)
4. Business logic errors (validation, processing errors)

### Key Features

#### Database Export/Import to Google Drive
**Service:** `DatabaseExportService` with `DatabaseExportProvider`

**Export process:**
1. Prompt user for password (via `PasswordDialog`)
2. Close database connection
3. Copy database to temporary location
4. Encrypt database file with password (PBKDF2 + AES-256)
5. Upload encrypted file to Google Drive's `appDataFolder`
6. Clean up and reopen database
7. Log audit entry

**Import process:**
1. List available backups from Google Drive
2. Prompt user for password (used during export)
3. Download encrypted file from Google Drive
4. Decrypt database file with password
5. Backup current database (optional)
6. Replace database with imported one
7. Reopen database connection
8. Log audit entry

**Security:**
- **Password-based encryption**: User-provided password required (not device-specific keys)
- **PBKDF2 key derivation**: 100,000 iterations with 32-byte unique salt
- **AES-256 encryption**: Industry-standard symmetric encryption
- **Portable backups**: Works across devices and app versions
- **User responsibility**: Password must be remembered (unrecoverable if lost)
- **Google Drive security**: Only stores encrypted data, encryption in transit (HTTPS/TLS)
- File naming: `ocrix_database_backup_YYYY-MM-DD.db.enc`

**UI Components:**
- `PasswordDialog`: Password input with strength indicator and confirmation
- `showExportPasswordDialog()`: Password setup for export (with confirmation)
- `showImportPasswordDialog()`: Password entry for import (no confirmation)

**Provider methods:**
```dart
final exportNotifier = ref.read(databaseExportNotifierProvider.notifier);

// Export requires password
final password = await showExportPasswordDialog(context);
await exportNotifier.exportDatabase(password: password); // Returns Google Drive file ID

// Import requires password
final password = await showImportPasswordDialog(context);
await exportNotifier.importDatabase(
  driveFileId: 'file_id',
  password: password,
  backupCurrent: true,
);

// List and delete backups
await exportNotifier.refreshBackups(); // List available backups
await exportNotifier.deleteBackup('file_id'); // Delete backup
```

**IMPORTANT:** If user forgets the password, the backup cannot be restored. The password dialog includes a prominent warning about this.

#### Image Processing
**Service:** `ImageProcessingService` (`IImageProcessingService`)
- Image preprocessing for OCR
- Format conversion
- Quality optimization
- Extracted from `DocumentNotifier` to follow SRP

#### Configuration Management
**Centralized in `AppConfig`:**
- Log rotation settings (24h interval, 10MB max)
- Log levels and file paths
- Database configuration
- Security settings

**Location:** `lib/core/config/app_config.dart`

## Important Development Notes

### Google Sign-In Configuration

**Required for authentication and Google Drive access:**
1. OAuth credentials configured in Google Cloud Console
2. Package name: `com.ocrix.app`
3. SHA-1 fingerprints required for both debug and release builds
4. No hardcoded Client ID needed - auto-detected by `google_sign_in` package

See README.md "Google Cloud Console Setup" for detailed configuration steps.

### Code Generation Requirements

When modifying models with JSON serialization:
1. Add/modify `@JsonSerializable()` annotation
2. Run `dart run build_runner build` to regenerate `.g.dart` files
3. Commit both model file and generated `.g.dart` file

### Testing Considerations

**Testing strategy:**
1. **Unit Tests**: Individual component testing - mock services by implementing interfaces
2. **Integration Tests**: Service interaction testing in `test/integration/`
3. **Widget Tests**: UI component testing
4. **End-to-End Tests**: Complete user journey testing

**Test coverage goals:**
- Core business logic: 90%+
- UI components: 80%+
- Service integrations: 85%+
- Error handling: 95%+

**Best practices:**
- Mock services by implementing interfaces (e.g., `MockEncryptionService` in `test/helpers/`)
- Integration tests in `test/integration/` test service interactions
- Camera service may fail in CI/test environments (gracefully handled in `AppInitializer`)
- Database tests should use `setDatabasePathOverride()` for custom paths
- Test with mocked dependencies using Riverpod's `ProviderScope` overrides

### Platform-Specific Considerations

- **Android**: Requires camera and storage permissions in manifest
- **iOS**: Requires camera usage description in Info.plist
- **Web**: Uses `sqflite_common_ffi_web` for database
- **Desktop**: Uses `sqflite_common_ffi` for database

### Important Development Workflows

#### Adding a New Service
1. Create interface in `lib/core/interfaces/{service_name}_interface.dart`
2. Create service class in `lib/services/{service_name}.dart` extending `BaseService`
3. Implement the interface and required methods
4. Add Riverpod provider in appropriate provider file
5. Inject troubleshooting logger via `setTroubleshootingLogger()` in `AppInitializer`
6. Add initialization call to `AppInitializer._initializeApp()` if needed
7. Create tests in `test/` and mock in `test/helpers/`

#### Working with Audit Logging
When implementing features that modify data:
1. Use `auditService.logCompulsory()` for all database operations
2. Use `auditService.logInfoAction()` for user-initiated actions
3. Use `auditService.logNavigation()` for screen transitions (or let `AuditNavigationObserver` handle it)
4. Set user ID context: `auditService.setUserId(userId)` after authentication
5. For database operations, set user ID for triggers: `databaseService.setCurrentUserIdForTriggers(userId)`

#### Refactoring Notes (In Progress)
The codebase is transitioning from singleton services to pure dependency injection:
- Services currently use singleton pattern but implement interfaces
- Gradually migrating to constructor injection via Riverpod
- `DatabaseService`, `EncryptionService`, `OCRService`, `CameraService` being refactored
- See `docs/architecture/REFACTORING_SUMMARY.md` for status

**When refactoring services:**
1. Keep old implementation temporarily
2. Create new implementation alongside
3. Update providers gradually
4. Remove old code once migration complete

### Privacy-First Design Principles

OCRix is privacy-first by design:
- All OCR processing happens on-device
- No analytics or tracking
- User controls all data storage locations
- Complete audit trail of all operations
- Right to erasure implemented

When adding features, maintain these principles by:
- Processing data locally when possible
- Explicit user consent for cloud operations
- Comprehensive audit logging for sensitive operations
- Clear data deletion mechanisms

## Data Flow Patterns

### Document Scanning Flow
```
Camera → Image Capture → OCR Processing → Text Extraction →
Document Creation → Database Storage → Search Index Update → Audit Log
```

### Search Flow
```
User Query → Search Service → FTS5 Index → Results Processing → UI Display
```

### Cloud Sync Flow
```
Local Changes → Sync Queue → Provider Upload → Remote Storage → Status Update → Audit Log
```

### Database Export Flow
```
Close DB → Copy DB → Encrypt (AES-256) → Upload to Google Drive (appDataFolder) →
Clean up → Reopen DB → Audit Log
```

## Recent Bug Fixes and Improvements

### Password-Based Database Encryption (December 2024)
**Problem:** Database exports were encrypted with device-specific keys, making them non-portable across devices.

**Solution:** Implemented PBKDF2-based password encryption:
- User provides password during export (with strength indicator and confirmation)
- PBKDF2 with 100,000 iterations derives encryption key from password
- Backups work across devices and app versions
- See `docs/fixes/BUG_FIX_SUMMARY.md` for migration details

**Files changed:**
- `lib/services/encryption_service.dart` - Added `encryptFileWithPassword()` and `decryptFileWithPassword()`
- `lib/services/database_export_service.dart` - Added password parameters
- `lib/ui/widgets/password_dialog.dart` - New password input widget

### IV Management Fix (December 2024)
**Problem:** Database imports failed after app reinstall because IV (Initialization Vector) was randomly generated but never stored.

**Solution:** Prepend IV to encrypted data: `[IV (16 bytes)][Encrypted Data]`
- Each encryption generates unique IV
- IV stored with encrypted data (self-contained files)
- Works across app versions

**Files changed:**
- `lib/services/encryption_service.dart` - Updated `encryptBytes()` and `decryptBytes()` to prepend IV

### Scroll Fix in Document Search (December 2024)
**Problem:** Scroll not working in Documents tab when searching.

**Solution:** Made `DocumentGrid` widget configurable:
- Added optional `controller`, `physics`, and `shrinkWrap` parameters
- Default to `AlwaysScrollableScrollPhysics()` for scrollable grids
- Backward compatible with existing usage in `HomeScreen`

**Files changed:**
- `lib/ui/widgets/document_grid.dart` - Added optional scroll parameters

## Documentation References

Comprehensive documentation is available in `docs/`:
- **Architecture**: `docs/architecture/system-architecture.md` - System design overview
- **Audit System**: `docs/AUDIT_LOGGING_SYSTEM.md` - Tamper-proof audit logging
- **Troubleshooting**: `docs/TROUBLESHOOTING_LOGGING_SYSTEM.md` - File-based logging for support
- **DB Export/Import**: `docs/features/DATABASE_EXPORT_IMPORT.md` - Google Drive backup feature
- **Refactoring Status**: `docs/architecture/REFACTORING_SUMMARY.md` - SOLID refactoring progress
- **Bug Fixes**: `docs/fixes/BUG_FIX_SUMMARY.md` - Detailed bug fix documentation
- **Service Interfaces**: `docs/api/service-interfaces.md` - API contracts
- **Requirements**: `docs/requirements/requirements.md` - Functional requirements
- **User Guide**: `docs/user-guide/getting-started.md` - End-user documentation
- **Google Drive Setup**: `docs/features/google-drive/` - Google Drive integration guides
