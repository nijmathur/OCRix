# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Build & Run Commands

### Development
- **Install dependencies**: `flutter pub get`
- **Generate code** (run after modifying JSON serialization): `dart run build_runner build`
- **Run app**: `flutter run`
- **Run app on specific device**: `flutter run -d <device-id>`
- **Clean build**: `flutter clean && flutter pub get`

### Testing
- **Run all tests**: `flutter test`
- **Run specific test file**: `flutter test test/widget_test.dart`
- **Run integration tests**: `flutter test test/integration/`
- **Run with coverage**: `flutter test --coverage`

### Build for Production
- **Android APK**: `flutter build apk --release`
- **Android App Bundle**: `flutter build appbundle --release`
- **iOS**: `flutter build ios --release`
- **Web**: `flutter build web --release`
- **Desktop**: `flutter build windows|macos|linux --release`

### Code Analysis
- **Analyze code**: `flutter analyze`
- **Format code**: `dart format .`

## High-Level Architecture

### Layered Architecture Pattern

OCRix follows a clean architecture with clear separation of concerns:

```
Presentation (UI) → State Management (Providers) → Business Logic (Services) → Data (Database/Storage)
```

**Key architectural principles (SOLID):**
1. **Single Responsibility**: Each service has one clear purpose (e.g., LogFormatterService only formats logs)
2. **Open/Closed**: Services implement interfaces, allowing extension without modification
3. **Liskov Substitution**: Services can be substituted with their interface types for testing
4. **Interface Segregation**: Separate interfaces for each concern (`IDatabaseService`, `IOCRService`, etc.)
5. **Dependency Inversion**: Services depend on abstractions (interfaces), not concrete implementations
6. **DRY Pattern**: Common functionality centralized in `BaseService` and `AppConfig`
7. **Provider-based DI**: Riverpod providers inject service implementations into UI layer
8. **Singleton Services**: Core services use singleton pattern (transitioning to pure DI)

### Core Services Layer

All services extend `BaseService` and implement their corresponding interface:

- **DatabaseService** (`IDatabaseService`): SQLite with FTS5 search, encryption, and audit triggers
- **EncryptionService** (`IEncryptionService`): AES-256 encryption and secure key storage
- **OCRService** (`IOCRService`): Google ML Kit text recognition
- **CameraService** (`ICameraService`): Camera operations and image capture
- **StorageProviderService** (`IStorageProviderService`): Cloud storage abstraction (Google Drive, etc.)
- **AuditLoggingService**: Comprehensive audit trail with COMPULSORY database logging
- **TroubleshootingLoggerService**: File-based logging for debugging

**Service Initialization Pattern:**
Services must be initialized via `initialize()` before use. The `AppInitializer` widget handles service initialization sequence in `lib/main.dart`.

### State Management with Riverpod

The app uses Riverpod for dependency injection and state management:

- **Providers** (`lib/providers/`): Provide service instances and manage UI state
- **Notifiers**: `StateNotifier` classes that manage complex state (e.g., `DocumentNotifier`)
- **FutureProvider**: For async data fetching (e.g., `documentListProvider`)
- **Provider.family**: For parameterized providers (e.g., `documentProvider` by ID)

**Important**: All providers are defined in provider files (e.g., `document_provider.dart`, `auth_provider.dart`) and consumed via `ref.read()` or `ref.watch()` in widgets.

### Data Models and Serialization

Models in `lib/models/` use `json_serializable` for JSON serialization:
- Models have `.g.dart` companion files generated by `build_runner`
- After modifying model classes with `@JsonSerializable()`, run: `dart run build_runner build`
- Models implement equality via `Equatable` package

### Database Architecture

**SQLite with encryption:**
- Database file encrypted at rest using `encrypt` package
- FTS5 virtual tables for full-text search
- SQLite triggers for automatic audit logging
- User ID context set via `setCurrentUserIdForTriggers()` for trigger identification

**Important patterns:**
- Database operations must set user ID context for audit triggers
- Use `ConflictAlgorithm.replace` for upsert operations
- Image data stored as encrypted BLOB in database

### Audit and Logging System

**Three-tier logging architecture:**

#### 1. Console Logging (Development)
- Via `Logger` package for development debugging
- Automatic logging in all services via `BaseService` methods: `logInfo()`, `logWarning()`, `logError()`, `logDebug()`

#### 2. Troubleshooting Logging (File-based)
**Location:** `{app_documents}/logs/app.log`

**SOLID Architecture:**
- `LogFormatterService`: Formats log entries with timestamps and emojis
- `LogFileService`: Manages file operations
- `LogRotationService`: Handles log rotation (24h interval, 10MB max, keeps 5 archives)
- `TroubleshootingLoggerService`: Coordinates logging operations

**Features:**
- In-memory buffer (last 100 entries)
- Log levels: debug, info, warning, error, critical
- User-exportable logs via `LogExportDialog` widget
- Log rotation to prevent disk space issues
- Archive location: `{app_documents}/logs/archive/app_{timestamp}.log`

**Usage in services:**
All services call `setTroubleshootingLogger()` during initialization to inject logger dependency.

#### 3. Audit Logging (Tamper-proof)
**Separate database:** `audit_log.db` (separate from main `privacy_documents.db`)

**Three logging levels (priority-based):**
1. **COMPULSORY (Priority 3)**: Always logged, cannot be disabled - all database reads/writes
2. **INFO (Priority 1)**: User actions - document operations, search, export/import
3. **VERBOSE (Priority 2)**: Navigation events - screen transitions

**Tamper-proof mechanisms:**
- SHA-256 checksum for each entry
- Chain verification (each entry links to previous via `previousEntryId` and `previousChecksum`)
- Read-only operations (INSERT only, no UPDATE/DELETE)
- Integrity verification via `verifyIntegrity()` method

**Automatic logging:**
- Database operations automatically logged via SQLite triggers
- Navigation logged via `AuditNavigationObserver` in main.dart
- User ID tracked for all operations (set via `setUserId()`)

**Configuration:**
```dart
// Set log level (default: COMPULSORY only)
auditService.setLogLevel(AuditLogLevel.info); // or .verbose
```

### Authentication and Security

**Multi-layered security:**
- **Google Sign-In**: Primary authentication (OAuth2)
- **Biometric Auth**: Optional fingerprint/face unlock for app access
- **Data Encryption**: AES-256 for all data at rest
- **Secure Storage**: Encryption keys in platform secure storage (Keychain/Keystore)

**Biometric Auth Flow:**
- Enabled via `BiometricAuthNotifier` in `biometric_auth_provider.dart`
- App lifecycle listener in `AppInitializer` triggers biometric prompt on resume
- Fallback to Google Sign-In if biometric fails

### UI Screens

Screens in `lib/ui/screens/`:
- `SplashScreen`: App initialization loading
- `LoginScreen`: Google Sign-In authentication
- `HomeScreen`: Main document list and navigation
- `ScannerScreen`: Camera-based document scanning
- `DocumentDetailScreen`: View/edit document details
- `DocumentListScreen`: Searchable document grid/list
- `SettingsScreen`: App settings and preferences

### Error Handling

**Global error handling:**
- App runs in `runZonedGuarded` to catch async errors
- `ErrorHandler` utility initialized with troubleshooting logger
- Custom exceptions in `lib/core/exceptions/app_exceptions.dart`

**Error types:**
1. Network errors (connectivity, API failures)
2. Storage errors (file system, database issues)
3. Security errors (authentication, encryption failures)
4. Business logic errors (validation, processing errors)

### Key Features

#### Database Export/Import to Google Drive
**Service:** `DatabaseExportService` with `DatabaseExportProvider`

**Export process:**
1. Close database connection
2. Copy database to temporary location
3. Encrypt database file (AES-256)
4. Upload encrypted file to Google Drive's `appDataFolder`
5. Clean up and reopen database

**Import process:**
1. Download encrypted file from Google Drive
2. Decrypt database file
3. Backup current database (optional)
4. Replace database with imported one
5. Reopen database connection

**Security:**
- Database encrypted before upload (AES-256)
- Same encryption key as local data (stored in secure storage)
- Google Drive only stores encrypted data
- File naming: `ocrix_database_backup_YYYY-MM-DD.db.enc`

**Provider methods:**
```dart
final exportNotifier = ref.read(databaseExportNotifierProvider.notifier);
await exportNotifier.exportDatabase(); // Returns Google Drive file ID
await exportNotifier.importDatabase(driveFileId: 'file_id', backupCurrent: true);
await exportNotifier.refreshBackups(); // List available backups
await exportNotifier.deleteBackup('file_id'); // Delete backup
```

#### Image Processing
**Service:** `ImageProcessingService` (`IImageProcessingService`)
- Image preprocessing for OCR
- Format conversion
- Quality optimization
- Extracted from `DocumentNotifier` to follow SRP

#### Configuration Management
**Centralized in `AppConfig`:**
- Log rotation settings (24h interval, 10MB max)
- Log levels and file paths
- Database configuration
- Security settings

**Location:** `lib/core/config/app_config.dart`

## Important Development Notes

### Google Sign-In Configuration

**Required for authentication and Google Drive access:**
1. OAuth credentials configured in Google Cloud Console
2. Package name: `com.ocrix.app`
3. SHA-1 fingerprints required for both debug and release builds
4. No hardcoded Client ID needed - auto-detected by `google_sign_in` package

See README.md "Google Cloud Console Setup" for detailed configuration steps.

### Code Generation Requirements

When modifying models with JSON serialization:
1. Add/modify `@JsonSerializable()` annotation
2. Run `dart run build_runner build` to regenerate `.g.dart` files
3. Commit both model file and generated `.g.dart` file

### Testing Considerations

**Testing strategy:**
1. **Unit Tests**: Individual component testing - mock services by implementing interfaces
2. **Integration Tests**: Service interaction testing in `test/integration/`
3. **Widget Tests**: UI component testing
4. **End-to-End Tests**: Complete user journey testing

**Test coverage goals:**
- Core business logic: 90%+
- UI components: 80%+
- Service integrations: 85%+
- Error handling: 95%+

**Best practices:**
- Mock services by implementing interfaces (e.g., `MockEncryptionService` in `test/helpers/`)
- Integration tests in `test/integration/` test service interactions
- Camera service may fail in CI/test environments (gracefully handled in `AppInitializer`)
- Database tests should use `setDatabasePathOverride()` for custom paths
- Test with mocked dependencies using Riverpod's `ProviderScope` overrides

### Platform-Specific Considerations

- **Android**: Requires camera and storage permissions in manifest
- **iOS**: Requires camera usage description in Info.plist
- **Web**: Uses `sqflite_common_ffi_web` for database
- **Desktop**: Uses `sqflite_common_ffi` for database

### Important Development Workflows

#### Adding a New Service
1. Create interface in `lib/core/interfaces/{service_name}_interface.dart`
2. Create service class in `lib/services/{service_name}.dart` extending `BaseService`
3. Implement the interface and required methods
4. Add Riverpod provider in appropriate provider file
5. Inject troubleshooting logger via `setTroubleshootingLogger()` in `AppInitializer`
6. Add initialization call to `AppInitializer._initializeApp()` if needed
7. Create tests in `test/` and mock in `test/helpers/`

#### Working with Audit Logging
When implementing features that modify data:
1. Use `auditService.logCompulsory()` for all database operations
2. Use `auditService.logInfoAction()` for user-initiated actions
3. Use `auditService.logNavigation()` for screen transitions (or let `AuditNavigationObserver` handle it)
4. Set user ID context: `auditService.setUserId(userId)` after authentication
5. For database operations, set user ID for triggers: `databaseService.setCurrentUserIdForTriggers(userId)`

#### Refactoring Notes (In Progress)
The codebase is transitioning from singleton services to pure dependency injection:
- Services currently use singleton pattern but implement interfaces
- Gradually migrating to constructor injection via Riverpod
- `DatabaseService`, `EncryptionService`, `OCRService`, `CameraService` being refactored
- See `docs/architecture/REFACTORING_SUMMARY.md` for status

**When refactoring services:**
1. Keep old implementation temporarily
2. Create new implementation alongside
3. Update providers gradually
4. Remove old code once migration complete

### Privacy-First Design Principles

OCRix is privacy-first by design:
- All OCR processing happens on-device
- No analytics or tracking
- User controls all data storage locations
- Complete audit trail of all operations
- Right to erasure implemented

When adding features, maintain these principles by:
- Processing data locally when possible
- Explicit user consent for cloud operations
- Comprehensive audit logging for sensitive operations
- Clear data deletion mechanisms

## Data Flow Patterns

### Document Scanning Flow
```
Camera → Image Capture → OCR Processing → Text Extraction →
Document Creation → Database Storage → Search Index Update → Audit Log
```

### Search Flow
```
User Query → Search Service → FTS5 Index → Results Processing → UI Display
```

### Cloud Sync Flow
```
Local Changes → Sync Queue → Provider Upload → Remote Storage → Status Update → Audit Log
```

### Database Export Flow
```
Close DB → Copy DB → Encrypt (AES-256) → Upload to Google Drive (appDataFolder) →
Clean up → Reopen DB → Audit Log
```

## Documentation References

Comprehensive documentation is available in `docs/`:
- **Architecture**: `docs/architecture/system-architecture.md` - System design overview
- **Audit System**: `docs/AUDIT_LOGGING_SYSTEM.md` - Tamper-proof audit logging
- **Troubleshooting**: `docs/TROUBLESHOOTING_LOGGING_SYSTEM.md` - File-based logging for support
- **DB Export/Import**: `docs/features/DATABASE_EXPORT_IMPORT.md` - Google Drive backup feature
- **Refactoring Status**: `docs/architecture/REFACTORING_SUMMARY.md` - SOLID refactoring progress
- **Service Interfaces**: `docs/api/service-interfaces.md` - API contracts
- **Requirements**: `docs/requirements/requirements.md` - Functional requirements
- **User Guide**: `docs/user-guide/getting-started.md` - End-user documentation
